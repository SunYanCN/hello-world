
java通过jython可以调用python代码；但 jython不支持python3，故放弃。

java通过Native 调用python代码整体思路：
先将 Python 源代码转换成 C 代码，之后用 GCC 编译 C 代码为二进制模块 so/dll，接着进行一次 Java Native 接口封装，使用 Jar 打包命令转换成 Jar 包，然后 Java 便可以直接调用。


对于 Java 来说，能够本地调用的有两种：
Java 代码包
Native 代码模块


第一步：准备python代码：

root@c9cde75c1336:~/test2# cat Test.py
# FileName: Test.py
# 示例代码：将输入的字符串转变为大写

class AbcTest():
    def __init__(self):
        print("python类初始化")

    def logic(self, param):
        print('这是一个python函数，将输入的字符串转变为大写')
        print('python函数参数是： [%s]' % param)
        return param.upper()

abc_test = AbcTest()

# 接口函数，导出给Java Native的接口
def JNI_API_TestFunction(param):
  print("进入 JNI_API_test_function")
  result = abc_test.logic(param)
  print("离开 JNI_API_test_function")
  return result

----------------------------------------
注意1：这里在 python 源码中使用一种约定：以JNI_API_为前缀开头的函数表示为Python代码模块要导出对外调用的接口函数，这样做的目的是为了让我们的 Python 一键转 Jar 包系统能自动化识别提取哪些接口作为导出函数。
注意2：这一类接口函数的输入是一个 python 的 str 类型字符串，输出亦然，如此可便于移植以往通过JSON形式作为参数的 RESTful 接口。使用JSON的好处是可以对参数进行封装，支持多种复杂的参数形式，而不用重载出不同的接口函数对外调用。
注意3：还有一点需要说明的是，在接口函数前缀JNI_API_的后面，函数命名不能以 python 惯有的下划线命名法，而要使用驼峰命名法，注意这不是建议，而是要求，原因后续会提到。

第二步：准备一个 main.c 文件
这个文件的作用是对 Cython 转换生成的代码进行一次封装，封装成 Java JNI 接口形式的风格，以备下一步 Java 的使用。

root@bc0f5fc2c940:~/test2# cat main.c
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
#include <Python.h>
#include <stdio.h>

#ifndef _Included_main
#define _Included_main
#ifdef __cplusplus
extern "C" {
#endif

#if PY_MAJOR_VERSION < 3
# define MODINIT(name)  init ## name
#else
# define MODINIT(name)  PyInit_ ## name
#endif
PyMODINIT_FUNC  MODINIT(Test)(void);

JNIEXPORT void JNICALL Java_Test_initModule
(JNIEnv *env, jobject obj) {
  PyImport_AppendInittab("Test", MODINIT(Test));
  Py_Initialize();

  PyRun_SimpleString("import os");
  PyRun_SimpleString("__name__ = \"__main__\"");
  PyRun_SimpleString("import sys");
  PyRun_SimpleString("sys.path.append('./')");

  PyObject* m = PyInit_Test();
  if (!PyModule_Check(m)) {
        PyModuleDef *mdef = (PyModuleDef *) m;
        PyObject *modname = PyUnicode_FromString("__main__");
        m = NULL;
        if (modname) {
          m = PyModule_NewObject(modname);
          Py_DECREF(modname);
          if (m) PyModule_ExecDef(m, mdef);
        }
  }
  PyEval_InitThreads();
}


JNIEXPORT void JNICALL Java_Test_uninitModule
(JNIEnv *env, jobject obj) {
  Py_Finalize();
}

JNIEXPORT jstring JNICALL Java_Test_testFunction
(JNIEnv *env, jobject obj, jstring string)
{
  const char* param = (char*)(*env)->GetStringUTFChars(env, string, NULL);
  static PyObject *s_pmodule = NULL;
  static PyObject *s_pfunc = NULL;
  if (!s_pmodule || !s_pfunc) {
    s_pmodule = PyImport_ImportModule("Test");
    s_pfunc = PyObject_GetAttrString(s_pmodule, "JNI_API_TestFunction");
  }
  PyObject *pyRet = PyObject_CallFunction(s_pfunc, "s", param);
  (*env)->ReleaseStringUTFChars(env, string, param);
  if (pyRet) {
    jstring retJstring = (*env)->NewStringUTF(env, PyUnicode_AsUTF8(pyRet));
    Py_DECREF(pyRet);
    return retJstring;
  } else {
    PyErr_Print();
    return (*env)->NewStringUTF(env, "error");
  }
}
#ifdef __cplusplus
}
#endif
#endif

--------------------------------------------------------------------------------------
这个文件中一共有3个函数：

Java_Test_initModule: python初始化工作
Java_Test_uninitModule: python反初始化工作
Java_Test_TestFunction: 真正的业务接口，封装了对原来Python中定义对JNI_API_testFuncion函数的调用，同时要负责JNI层面的参数jstring类型的转换。
大小写等，需要与Test.py文件中一致，否则后面会报错：
root@bc0f5fc2c940:~/java2# java Demo
AttributeError: module 'Test' has no attribute 'JNI_API_testFunction'

另外 main.c 文件中：
JNIEXPORT void JNICALL Java_Test2_initModule
JNIEXPORT void JNICALL Java_Test2_uninitModule
JNIEXPORT jstring JNICALL Java_Test2_testFunction
函数名称需要与java中 native 关键词定义的一致：
public class Test2 {
    public native void initModule();
    public native void uninitModule();
    public native String testFunction(String param);

Java_包名_java类名_java内native函数名；
JNIEXPORT jint JNICALL Java_packagename_classname_methodname();  // jint 指的返回数据类型为int，JNICALL 后面指定了调用JNI方法的包名和类名、方法名...

第三步：Python 代码如何转换成 C 代码
即使用 Cython 工具编译生成动态库
Cython 能够把 Python 脚本转换成 C 代码
Cython 是 Python 的一个第三方库，你可以通过pip install Cython进行安装。

python源代码Test.py和main.c文件都准备就绪，接下来便是Cython登场的时候了，它将会将所有pyx的文件自动转换成.c文件，并结合我们自己的main.c文件，内部调用gcc生成一个动态二进制库文件。
Cython 的工作需要准备一个 setup.py 文件，配置好转换的编译信息，包括输入文件、输出文件、编译参数、包含目录、链接目录，如下所示：

root@bc0f5fc2c940:~/test2# cat setup.py
from distutils.core import setup
from Cython.Build import cythonize
from distutils.extension import Extension

sourcefiles = ['Test.py', 'main.c']

extensions = [Extension("Test", sourcefiles,
  include_dirs=['/root/java/jdk1.8.0_191/include/',
    '/root/java/jdk1.8.0_191/include/linux/',
    '/usr/local/include/python3.6m/'],
  library_dirs=['/usr/local/lib/'],
  libraries=['python3.6m'])]

setup(ext_modules=cythonize(extensions, language_level = 3))
-----------------------------------------------------------------------------------------
注意：这里涉及Python二进制代码的编译，需要链接Python的库

注意：这里涉及JNI相关数据结构定义，需要包含Java JNI目录
注意：setup.py中Extension第一个参数是 name，表示的是这个 extension 的全称，而之后的调用就会依托这个名字，同时在 main.c 中 PyInit_ 之后接的是该模块的名称。也就是说，当这两个名称相同的时候，Cython 才能成功编译这个模块。
否则可能会出现如下错误：
root@bc0f5fc2c940:~/java2# java Demo
java: symbol lookup error: /root/test2/Test_Test.cpython-36m-x86_64-linux-gnu.so: undefined symbol: PyInit_Test_Test

setup.py文件准备就绪后，便执行如下命令，启动转换＋编译工作：

python3.6 setup.py build_ext --inplace
生成我们需要的动态库文件：Test***.so

root@bc0f5fc2c940:~/test2# ls
Test.py  main.c  setup.py
root@bc0f5fc2c940:~/test2# python3.6 setup.py build_ext --inplace
Compiling Test.py because it changed.
[1/1] Cythonizing Test.py
running build_ext
building 'Test' extension
creating build
creating build/temp.linux-x86_64-3.6
gcc -pthread -Wno-unused-result -Wsign-compare -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -fPIC -I/root/java/jdk1.8.0_191/include/ -I/root/java/jdk1.8.0_191/include/linux/ -I/usr/local/include/python3.6
m/ -I/usr/local/include/python3.6m -c Test.c -o build/temp.linux-x86_64-3.6/Test.o
gcc -pthread -Wno-unused-result -Wsign-compare -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -fPIC -I/root/java/jdk1.8.0_191/include/ -I/root/java/jdk1.8.0_191/include/linux/ -I/usr/local/include/python3.6
m/ -I/usr/local/include/python3.6m -c main.c -o build/temp.linux-x86_64-3.6/main.o
gcc -pthread -shared build/temp.linux-x86_64-3.6/Test.o build/temp.linux-x86_64-3.6/main.o -L/usr/local/lib/ -L/usr/local/lib -lpython3.6m -lpython3.6m -o /root/test2/Test.cpython-36m-x86_64-linux-gnu.so


第四步：准备Java JNI调用的接口文件
Java业务代码使用需要定义一个接口，如下所示：

root@c9cde75c1336:~/java2# cat Test.java
import java.io.IOException;

public class Test {
    public native void initModule();
    public native void uninitModule();
    public native String testFunction(String param);
    // public synchronized static void loadLibrary() throws IOException {
    static {
        String SO_FILE_PATH = "/root/test2/Test.cpython-36m-x86_64-linux-gnu.so";
        System.load(SO_FILE_PATH);
        System.out.println(String.format("加载so文件完成: %s", SO_FILE_PATH));
    }
}

到这一步，其实已经实现了在Java中调用的目的了，注意调用业务接口之前，需要先调用initModule进行native层面的Python初始化工作,如下：
root@c9cde75c1336:~/java2# cat Demo.java
//import Test;

public class Demo {
    static Test tester = new Test();
    public static void main(String[] args) {
            //System.load("/root/test2/Test.cpython-36m-x86_64-linux-gnu.so");
            //Test tester = new Test();
            //tester.loadLibrary();
            tester.initModule();

            String result = tester.testFunction("从java中调用abcd");
            System.out.println(String.format("java调用python函数的返回结果：%s", result));
            String result2 = tester.testFunction("从java中二次调用xyz");
            tester.uninitModule();

            System.out.println(String.format("java调用python函数的返回结果：%s", result2));
                                                                        }
}

准备好了后，开始编译并命令行调用java代码：
root@bc0f5fc2c940:~/java2# ls
Demo.java  Test.java
root@bc0f5fc2c940:~/java2# javac -encoding UTF-8 Test.java Demo.java
root@bc0f5fc2c940:~/java2# ls
Demo.class  Demo.java  Test.class  Test.java
root@bc0f5fc2c940:~/java2# java Demo
加载so文件完成: /root/test2/Test.cpython-36m-x86_64-linux-gnu.so
python类初始化
进入 JNI_API_test_function
这是一个python函数，将输入的字符串转变为大写
python函数参数是： [从java中调用abcd]
离开 JNI_API_test_function
java调用python函数的返回结果：从JAVA中调用ABCD
进入 JNI_API_test_function
这是一个python函数，将输入的字符串转变为大写
python函数参数是： [从java中二次调用xyz]
离开 JNI_API_test_function
java调用python函数的返回结果：从JAVA中二次调用XYZ

第五步：封装为 Jar 包
做到上面这样还不能满足，为了更好的使用体验，我们再往前一步，封装成为Jar包。
首先原来的JNI接口文件需要再扩充一下，加入一个静态方法loadLibrary，自动实现so文件的释放和加载。
// FileName: Test.java
public class Test {
  public native void initModule();
  public native void uninitModule();
  public native String testFunction(String param);
  public synchronized static void loadLibrary() throws IOException {
    // 实现略...
  ｝
}
接着将上面的接口文件转换成java class文件:
javac Test.java
最后，准备将class文件和so文件放置于Test目录下，打包：
jar cvfm Test.jar ./Test

使用过程，若报错：
每当 Java 并发数一上去之后，JVM 总是不定时出现 Crash
在 JNI 调用入口需要获得 GIL 锁，接口退出时需要释放 GIL 锁。
PyGILState_STAGE PyGILState_Ensure();
void PyGILState_Release(PyGILState_STAGE);

调用so文件若报错：
# A fatal error has been detected by the Java Runtime Environment:
#
#  SIGSEGV (0xb) at pc=0x00007f77a307bf90, pid=1029, tid=0x00007f77c08e9700
#
# JRE version: Java(TM) SE Runtime Environment (8.0_191-b12) (build 1.8.0_191-b12)
# Java VM: Java HotSpot(TM) 64-Bit Server VM (25.191-b12 mixed mode linux-amd64 compressed oops)
# Problematic frame:
# C  [libTest.so+0x11f90]  Java_Test_initModule+0x60
#
# Core dump written. Default location: /root/java2/core or core.1029
#
# An error report file with more information is saved as:
则可能是对应的编译为so文件的程序出错，比如，.py文件编译为so文件；
py文件读取json文件时候，不出错，编译后却出错：
出错：Extra data: line 1 column 642598 (char 642597)
这个时候，可以将json文件转换为pkl文件，通过pkl文件进行读取即可。

作者：轩辕之风
链接：https://juejin.cn/post/6844903972596088846
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

