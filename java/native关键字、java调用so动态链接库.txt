
一个Native Method就是一个java调用非java代码的接口。一个Native Method是这样一个java的方法：该方法的实现由非java语言实现，比如C。这个特征并非java所特有，很多其它的编程语言都有这一机制，比如在C＋＋中，你可以用extern "C"告知C＋＋编译器去调用一个C的函数。

标识符native可以与所有其它的java标识符连用，但是abstract除外。这是合理的，因为native暗示这些方法是有实现体的，只不过这些实现体是非java的，但是abstract却显然的指明这些方法无实现体。native与其它java标识符连用时，其意义同非Native Method并无差别。

    一个native method方法可以返回任何java类型，包括非基本类型，而且同样可以进行异常控制。这些方法的实现体可以自制一个异常并且将其抛出，这一点与java的方法非常相似。
    native method的存在并不会对其他类调用这些本地方法产生任何影响，实际上调用这些方法的其他类甚至不知道它所调用的是一个本地方法。JVM将控制调用本地方法的所有细节。

当一个类第一次被使用到时，这个类的字节码会被加载到内存，并且只会回载一次。在这个被加载的字节码的入口维持着一个该类所有方法描述符的list，这些方法描述符包含这样一些信息：方法代码存于何处，它有哪些参数，方法的描述符（public之类）等等。
    如果一个方法描述符内有native，这个描述符块将有一个指向该方法的实现的指针。这些实现在一些DLL文件内，但是它们会被操作系统加载到java程序的地址空间。当一个带有本地方法的类被加载时，其相关的DLL并未被加载，因此指向方法实现的指针并不会被设置。当本地方法被调用之前，这些DLL才会被加载，这是通过调用java.system.loadLibrary()实现的。

使用本地方法是有开销的，它丧失了java的很多好处。如果别无选择，我们可以选择使用本地方法。

可以将native方法比作Java程序同Ｃ程序的接口，其实现步骤：
１、在Java中声明native()方法，然后编译；
２、用javah产生一个.h文件；
３、写一个.cpp文件实现native导出方法，其中需要包含第二步产生的.h文件（注意其中又包含了JDK带的jni.h文件）；
４、将第三步的.cpp文件编译成动态链接库文件；
５、在Java中用System.loadLibrary()方法加载第四步产生的动态链接库文件，这个native()方法就可以在Java中被访问了。

第一步：创建HelloWorld.java
root@c9cde75c1336:~/HelloWorld# cat HelloWorld.java
class HelloWorld
{
        private native void print();
        public static void main(String[] args)
        {
                new HelloWorld().print();
        }

        static
        {
                System.loadLibrary("HelloWorld");
        }
}

注意print方法的声明，关键字native表明该方法是一个原生代码实现的。另外注意static代码段的System.loadLibrary调用，这段代码表示在程序加载的时候，自动加载libHelloWorld.so库。

第二步：编译HelloWorld.java
在命令行中运行如下命令：
root@c9cde75c1336:~/HelloWorld# javac HelloWorld.java
运行后会在当前文件夹编译生成HelloWorld.class。

第三步：生成HelloWorld.h
在命令行中运行如下命令：
root@c9cde75c1336:~/HelloWorld# javah -jni HelloWorld
在当前文件夹中会生成HelloWorld.h。打开HelloWorld.h将会发现如下代码：
root@c9cde75c1336:~/HelloWorld# cat HelloWorld.h
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class HelloWorld */

#ifndef _Included_HelloWorld
#define _Included_HelloWorld
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     HelloWorld
 * Method:    print
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_HelloWorld_print
  (JNIEnv *, jobject);

#ifdef __cplusplus
}
#endif
#endif
root@c9cde75c1336:~/HelloWorld#
该文件中包含了一个函数Java_HelloWorld_print的声明。

第四步：实现HelloWorld.c
创建HelloWorld.c文件输入如下的代码：
root@c9cde75c1336:~/HelloWorld# cat HelloWorld.c
#include <jni.h>
#include <stdio.h>
#include "HelloWorld.h"

JNIEXPORT void JNICALL

Java_HelloWorld_print(JNIEnv *env, jobject obj)
{
        printf("Hello World，你好!\n");
}

root@c9cde75c1336:~/HelloWorld#

注意必须要包含jni.h头文件，该文件中定义了JNI用到的各种类型，宏定义等。
另外需要注意Java_HelloWorld_print的两个参数。
env代表java虚拟机环境，Java传过来的参数和c有很大的不同，需要调用JVM提供的接口来转换成C类型的，就是通过调用env方法来完成转换的。
obj代表调用的对象，相当于c++的this。当c函数需要改变调用对象成员变量时，可以通过操作这个对象来完成。

第五步：编译生成libHelloWorld.so
在Linux下执行如下命令来完成编译工作：
root@c9cde75c1336:~/HelloWorld# gcc -I $JAVA_HOME/include -I $JAVA_HOME/include/
linux -fPIC -shared -o libHelloWorld.so HelloWorld.c

在当前目录生成libHelloWorld.so。注意一定需要包含Java的include目录（请根据自己系统环境设定），因为Helloworld.c中包含了jni.h。
另外一个值得注意的是在HelloWorld.java中我们LoadLibrary方法加载的是
“HelloWorld”，可我们生成的Library却是libHelloWorld。这是Linux的链接规定的，一个库的必须要是：lib+库名+.so。链接的时候只需要提供库名就可以了。

第六步：运行Java程序HelloWorld
root@c9cde75c1336:~/HelloWorld# java HelloWorld
Exception in thread "main" java.lang.UnsatisfiedLinkError: no HelloWorld in java
.library.path
        at java.lang.ClassLoader.loadLibrary(ClassLoader.java:1867)
        at java.lang.Runtime.loadLibrary0(Runtime.java:870)
        at java.lang.System.loadLibrary(System.java:1122)
        at HelloWorld.<clinit>(HelloWorld.java:11)
收到java.lang.UnsatisfiedLinkError异常，可以通过如下方式指明共享库的路径：
root@c9cde75c1336:~/HelloWorld# java -Djava.library.path='.' HelloWorld
Hello World，你好!

-----------------------------------------------------------------------------------------
java加载.so三种方式
1.使用绝对路径加载，System.load("absolutePath/library.so“);
2.将链接库放在java.library.path指定的目录下，System.loadLibrary("library");
但是两者对路径依赖都比较强，尤其是前者。
3.在Java 8中， System.loadLibrary 会调用 ClassLoader.loadLibrary0 加载native库，后者从静态成员 usr_paths 中搜索。基于这一点，我们可以将so打包在jar中。在运行时，把so复制到临时目录，然后修改 ClassLoader.usr_paths ，再调用 System.loadLibrary 完成so的加载。
先把so文件当成普通文件一起打包到jar包，由于.so文件这时候被压缩了，所以不能直接使用，需要动态加载到动态库中，动态加载的方式是Thread.currentThread().getContextClassLoader().getResourceAsStream() 获取到文件流 ，把内容全部读取出来然后使用System.load()加入到动态库中；
怎么把java类和JNI调用的DLL打包成jar, 方法如下：
//BIN_LIB为JAR包中存放DLL的路径
//getResourceAsStream以JAR中根路径为开始点
import java.io.*;

private synchronized static void loadLib(String libName) throws IOException {
    String systemType = System.getProperty("os.name");
    String libExtension = (systemType.toLowerCase().indexOf("win")!=-1) ? ".dll" : ".so";
    String libFullName = libName + libExtension;
    String nativeTempDir = System.getProperty("java.io.tmpdir");
    InputStream in = null;
    BufferedInputStream reader = null;
    FileOutputStream writer = null;
    File extractedLibFile = new File(nativeTempDir+File.separator+libFullName);
    if(!extractedLibFile.exists()){
        try {
            in = SMAgent.class.getResourceAsStream(BIN_LIB + libFullName);
            if(in==null)
                in = SMAgent.class.getResourceAsStream(libFullName);
            SMAgent.class.getResource(libFullName);
            reader = new BufferedInputStream(in);
            writer = new FileOutputStream(extractedLibFile);
            byte[] buffer = new byte[1024];
            while (reader.read(buffer) > 0){
                writer.write(buffer);
                buffer = new byte[1024];
            }
        } catch (IOException e){
            e.printStackTrace();
        } finally {
            if(in!=null)
                in.close();
            if(writer!=null)
                writer.close();
        }
    }
    System.load(extractedLibFile.toString());
}

以上 SMAgent 为类名；

资料来源：
https://www.cnblogs.com/duanxz/p/3651347.html


