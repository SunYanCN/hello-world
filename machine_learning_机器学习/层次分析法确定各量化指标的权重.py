#!/usr/bin/env python3
# -*- coding: utf-8 -*-


'''
层次分析法（Analytic Hierarchy Process，AHP），用于确定评价模型中各评价因子/准则的权重，进一步选择最优方案。该方法仍具有较强的主观性，判断/比较矩阵的构造在一定程度上是拍脑门决定的，一致性检验只是检验拍脑门有没有自相矛盾得太离谱。
　　运用AHP法进行决策时，需要经历以下4个步骤：
　　1、建立系统的递阶层次结构；
　　2、构造两两比较判断矩阵；（正互反矩阵）
　　3、针对某一个标准，计算各备选元素的权重；
　　4、计算当前一层元素关于总目标的排序权重。
　　5、进行一致性检验。

　　构造好判断矩阵后，需要根据判断矩阵计算针对某一准则层各元素的相对权重，并进行一致性检验。虽然在构造判断矩阵A时并不要求判断具有一致性，但判断偏离一致性过大也是不允许的。因此需要对判断矩阵A进行一致性检验。

'''
import numpy as np

class AnalyticHierarchyProcess:
    """
    相关信息的传入和准备
    """

    def __init__(self, array):
        ## 记录矩阵相关信息
        self.array = array
        ## 记录矩阵大小
        self.n = array.shape[0]
        # 初始化RI值，用于一致性检验, 数据来源：洪志国、李焱等. 层次分析法中高阶平均随机一致性指标(ri)的计算
        self.RI_list = [0, 0, 0.52, 0.89, 1.12, 1.26, 1.36, 1.41, 1.46, 1.49, 1.52, 1.54, 1.56, 1.58,
                        1.59, 1.5943, 1.6064, 1.6133, 1.6207, 1.6292, 1.6358, 1.6403, 1.6462, 1.6497,
                        1.6556, 1.6587, 1.6631, 1.6670, 1.6693, 1.6724]
        # 矩阵的特征值和特征向量
        self.eig_val, self.eig_vector = np.linalg.eig(self.array)
        # 矩阵的最大特征值
        self.max_eig_val = np.max(self.eig_val)
        # 矩阵最大特征值对应的特征向量
        self.max_eig_vector = self.eig_vector[:, np.argmax(self.eig_val)].real
        # 矩阵的一致性指标CI
        self.CI_val = (self.max_eig_val - self.n) / (self.n - 1)
        # 矩阵的一致性比例CR
        self.CR_val = self.CI_val / (self.RI_list[self.n - 1])

    """
    一致性判断
    """

    def test_consist(self):
        # 打印矩阵的一致性指标CI和一致性比例CR
        print("判断矩阵的CI值为：" + str(self.CI_val))
        print("判断矩阵的CR值为：" + str(self.CR_val))
        # 进行一致性检验判断
        if self.n == 2:  # 当只有两个子因素的情况
            print("仅包含两个子因素，不存在一致性问题")
        else:
            if self.CR_val < 0.1:  # CR值小于0.1，可以通过一致性检验
                print("判断矩阵的CR值为" + str(self.CR_val) + ",通过一致性检验")
                return True
            else:  # CR值大于0.1, 一致性检验不通过
                print("判断矩阵的CR值为" + str(self.CR_val) + "未通过一致性检验")
                return False

    """
    算术平均法求权重
    """

    def cal_weight_by_arithmetic_method(self):
        # 求矩阵的每列的和
        col_sum = np.sum(self.array, axis=0)
        # 将判断矩阵按照列归一化
        array_normed = self.array / col_sum
        # 计算权重向量
        array_weight = np.sum(array_normed, axis=1) / self.n
        # 打印权重向量
        print("算术平均法计算得到的权重向量为：\n", array_weight)
        # 返回权重向量的值
        return array_weight

    """
    几何平均法求权重
    """

    def cal_weight__by_geometric_method(self):
        # 求矩阵的每列的积
        col_product = np.product(self.array, axis=1)
        # 将得到的积向量的每个分量进行开n次方
        array_power = np.power(col_product, 1 / self.n)
        # 将列向量归一化
        array_weight = array_power / np.sum(array_power)
        # 打印权重向量
        print("几何平均法计算得到的权重向量为：\n", array_weight)
        # 返回权重向量的值
        return array_weight

    """
    特征值法求权重
    """

    def cal_weight__by_eigenvalue_method(self):
        # 将矩阵最大特征值对应的特征向量进行归一化处理就得到了权重
        array_weight = self.max_eig_vector / np.sum(self.max_eig_vector)
        # 打印权重向量
        print("特征值法计算得到的权重向量为：\n", array_weight)
        # 返回权重向量的值
        return array_weight



def main():
    # 给出判断矩阵
    b = np.array([[1, 1 / 3, 1 / 8], [3, 1, 1 / 3], [8, 3, 1]])
    ts = [[float(i) for i in t.split()] for t in '''1.00 	3	0.2	0.2	0.5	1	0.333333333	1	0.333333333	0.333333333	0.333333333	0.333333333	0.333333333	0.333333333	0.333333333	0.111111111	0.2	0.111111111
0.33 	1.00 	0.333333333	0.333333333	1	0.333333333	1	2	0.333333333	0.333333333	0.333333333	0.333333333	0.333333333	0.333333333	0.5	0.111111111	0.2	0.111111111
5.00 	3.00 	1.00 	0.333333333	3	1	1	2	0.333333333	0.333333333	0.333333333	0.333333333	0.333333333	0.333333333	0.333333333	0.111111111	0.2	0.111111111
5.00 	3.00 	3.00 	1.00 	3	3	3	3	1	0.5	0.5	1	0.5	0.5	2	0.111111111	2	0.111111111
2.00 	1.00 	0.33 	0.33 	1.00 	2	2	2	0.5	0.5	0.5	0.5	0.5	0.5	0.5	0.111111111	0.5	0.111111111
1.00 	3.00 	1.00 	0.33 	0.50 	1.00 	1	2	0.333333333	0.333333333	0.333333333	0.333333333	0.333333333	0.333333333	0.5	0.111111111	0.5	0.111111111
3.00 	1.00 	1.00 	0.33 	0.50 	1.00 	1.00 	2	0.333333333	0.333333333	0.333333333	0.333333333	0.333333333	0.333333333	0.5	0.111111111	0.5	0.111111111
1.00 	0.50 	0.50 	0.33 	0.50 	0.50 	0.50 	1.00 	0.333333333	0.333333333	0.333333333	0.333333333	0.333333333	0.333333333	0.333333333	0.111111111	0.5	0.111111111
3.00 	3.00 	3.00 	1.00 	2.00 	3.00 	3.00 	3.00 	1.00 	0.333333333	0.333333333	1	0.333333333	0.333333333	1	0.111111111	1	0.111111111
3.00 	3.00 	3.00 	2.00 	2.00 	3.00 	3.00 	3.00 	3.00 	1.00 	1	2	1	2	2	0.111111111	2	0.111111111
3.00 	3.00 	3.00 	2.00 	2.00 	3.00 	3.00 	3.00 	3.00 	1.00 	1.00 	3	0.333333333	1	2	0.111111111	2	0.111111111
3.00 	3.00 	3.00 	1.00 	2.00 	3.00 	3.00 	3.00 	1.00 	0.50 	0.33 	1.00 	0.333333333	0.333333333	1	0.111111111	1	0.111111111
3.00 	3.00 	3.00 	2.00 	2.00 	3.00 	3.00 	3.00 	3.00 	1.00 	3.00 	3.00 	1.00 	2	2	0.111111111	2	0.111111111
3.00 	3.00 	3.00 	2.00 	2.00 	3.00 	3.00 	3.00 	3.00 	0.50 	1.00 	3.00 	0.50 	1.00 	2	0.111111111	2	0.111111111
3.00 	2.00 	3.00 	0.50 	2.00 	2.00 	2.00 	3.00 	1.00 	0.50 	0.50 	1.00 	0.50 	0.50 	1.00 	0.111111111	1	0.111111111
9.00 	9.00 	9.00 	9.00 	9.00 	9.00 	9.00 	9.00 	9.00 	9.00 	9.00 	9.00 	9.00 	9.00 	9.00 	1.00 	5	1
5.00 	5.00 	5.00 	0.50 	2.00 	2.00 	2.00 	2.00 	1.00 	0.50 	0.50 	1.00 	0.50 	0.50 	1.00 	0.20 	1.00 	0.111111111
9.00 	9.00 	9.00 	9.00 	9.00 	9.00 	9.00 	9.00 	9.00 	9.00 	9.00 	9.00 	9.00 	9.00 	9.00 	1.00 	9.00 	1.00  '''.split('\n')]
    b = np.array(ts)
    # 算术平均法求权重
    weight1 = AnalyticHierarchyProcess(b).cal_weight_by_arithmetic_method()
    # for k, v in zip('字段数	记录数	饱和度	正确性	一致度	距今天数	更新频率	关联表数	查看频率	交易频率	调用频率	查看量	交易量	调用量	稀缺度	安全分级	业务类别	收入金额'.split(), weight1):
    #     print("{}\t".format(k, v))
    # 几何平均法求权重
    weight2 = AnalyticHierarchyProcess(b).cal_weight__by_geometric_method()
    # 特征值法求权重
    weight3 = AnalyticHierarchyProcess(b).cal_weight__by_eigenvalue_method()
    analytic_hierarchy_process = AnalyticHierarchyProcess(b)
    analytic_hierarchy_process.test_consist()


if __name__ == '__main__':
    main()