# 发布订阅模式
发布/订阅模式（一对多，消费者消费数据之后不会清除消息）
消息生产者（发布）将消息发布到topic中，同时有多个消息消费者（订阅）消费该消息。和点对点模式 不同，发布到topic的消息会被所有订阅者消费。

1）模式特点：
消息生产者（发布）将消息发布到topic中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到topic的消息会被所有订阅者消费。

2）数据拉取方式：消费者主动拉取、消费者被动接受（类似微信公众号）

3）模式缺点：当数据拉取方式为消费者被动接受时，消费者的消费速度可能跟不上生产者的生产速度。

可以同时多个分区发布消息，如10条消息发布在某一主题，这个主题有10个分区，那么各个分区消息总数加起来为10，但不一定是刚好每个分区有且仅有一条消息；
同一分区消息可被多个消费者组订阅，但每个消费者组内只能由一个消费者消费；

如：主题test3, 分区：0, 消费者组1（含消费者a、消费者b）,消费者组2（含消费者c、消费者d）；
现在向test3发送10条消息，那么最终消费情况：
1、a消费10条，b消费0条,c消费10条,d消费0条；
1、a消费10条，b消费0条,c消费0条,d消费10条；
1、a消费0条，b消费10条,c消费10条,d消费0条；
1、a消费0条，b消费10条,c消费0条,d消费10条；

如，有两个消费者在同一个消费组，订阅同一主题，生产者将10条消息发送到10个分区；
情况1：每个消费者先订阅消息，再生产者发布消息，每个消费者，分别消费5个分区的任务，哪怕这5个分区任务耗时不一致也会这样；
情况2：有一个消费者先订阅消息，生产者发布消息，另一个消费者订阅消息，生产者再次发布消息；这个时候，第二个订阅者压根会接收不到消息，因为第一个消费者绑定了所有的分区；
所以，最好是消费者先订阅，生产者再发布消息，这样分区上的消息能均衡分配给每个消费者；但还是不能解决情况1的情况；

# 发布消息
python3 kafka_producer.py 

# 订阅消息1
python3 kafka_consumer.py  

# 订阅消息2
python3 kafka_consumer2.py  