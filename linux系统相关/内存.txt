
可用内存和已用内存？

除了 free -m 之外，也可以看 top

top 命令小技巧
1、输入大写P，则结果按CPU占用降序排序。
2、输入大写M，结果按内存占用降序排序。
3、按数字 1 则可以显示所有CPU核心的负载情况。
4、按小写字母c,可显示程序的运行路径，即显示命令名称和完整命令行

手动释放系统内存：
gswewf@gswewf-PC:~/yhb$ sudo -i
root@gswewf-PC:~# free -h
              total        used        free      shared  buff/cache   available
Mem:            15G        8.1G        3.4G        191M        4.1G        7.0G
Swap:          4.0G          0B        4.0G
root@gswewf-PC:~# echo 3 > /proc/sys/vm/drop_caches
root@gswewf-PC:~# free -h
              total        used        free      shared  buff/cache   available
Mem:            15G        8.1G        6.5G        188M        1.0G        7.0G
Swap:          4.0G          0B        4.0G


进入top界面后：

M —根据驻留内存大小进行排序
P —根据CPU使用百分比大小进行排序
T —根据时间/累计时间进行排序
c —切换显示命令名称和完整命令行
t —切换显示进程和CPU信息
m —切换显示内存信息
l —切换显示平均负载和启动时间信息
o —改变显示项目的顺序
f —从当前显示中添加或删除项目
S —切换到累计模式
s —改变两次刷新之间的延迟时间。系统将提示用户输入新的时间，单位为s。如果有小数，就换算成ms。输入0值则系统将不断刷新，默认值是5s；如果值设的很小，不但看不清结果，同时还会是系统负载大大增加
q —退出top程序
i —忽略闲置和僵尸进程。这是一个开关式的命令
k —终止一个进程，系统将提示用户输入需要终止的进程PID，以及需要发送给该进程什么样的信号。一般终止进程可以使用15信号；如果不能正常结束那就使用信号9强制结束进程；默认的信号是15；但是在安全模式中此命令被屏蔽

顶部的内存信息可以在top运行时按E切换，每次切换转换率为1000，只是没有单位，切换的单位为 k,m,g,t,p;
底下的进程信息按e切换，每次切换转换率为1000，切换的单位也是 k,m,g,t,p;

# Linux-查看cpu核数和个数、查看内存的命令
CPU个数：
cat /proc/cpuinfo | grep 'physical id' | sort | uniq | wc -l

CPU核数：
cat /proc/cpuinfo | grep 'process' | sort | uniq | wc -l

CPU核数，也可以通过top命令查看：
通过在 top 视图下按键盘的1，查看cpu的核数

内存：
cat /proc/meminfo

若是windows10系统，查看CPU核数，或内存，只需打开“任务管理器”，切换到“性能”选项卡，即可查看；
逻辑处理器数，往往就对应核数；

# 虚拟内存（Virtual Memory）和驻留内存（Resident Memory）
虚拟内存是一个假象的内存空间，在程序运行过程中虚拟内存空间中需要被访问的部分会被映射到物理内存空间中。虚拟内存空间大只能表示程序运行过程中可访问的空间比较大，不代表物理内存空间占用也大。
驻留内存，顾名思义是指那些被映射到进程虚拟内存空间的物理内存。进程的驻留内存就是进程实实在在占用的物理内存。一般我们所讲的进程占用了多少内存，其实就是说的占用了多少驻留内存而不是多少虚拟内存。因为虚拟内存大并不意味着占用的物理内存大。

# top命令中VIRT、RES和SHR分别代表什么：
VIRT表示的是进程虚拟内存空间大小。VIRT包含了在已经映射到物理内存空间的部分和尚未映射到物理内存空间的部分总和。
RES的含义是指进程虚拟内存空间中已经映射到物理内存空间的那部分的大小。所以说，看进程在运行过程中占用了多少内存应该看RES的值而不是VIRT的值。
SHR是share（共享）的缩写，它表示的是进程占用的共享内存大小。程序会依赖于很多外部的动态库（.so），比如libc.so、libld.so等等。这些动态库在内存中仅仅会保存/映射一份，如果某个进程运行时需要这个动态库，那么动态加载器会将这块内存映射到对应进程的虚拟内存空间中。多个进展之间通过共享内存的方式相互通信也会出现这样的情况。这么一来，就会出现不同进程的虚拟内存空间会映射到相同的物理内存空间。这部分物理内存空间其实是被多个进程所共享的，所以我们将他们称为共享内存，用SHR来表示。某个进程占用的内存除了和别的进程共享的内存之外就是自己的独占内存了。所以要计算进程独占内存的大小只要用RES的值减去SHR值即可。

