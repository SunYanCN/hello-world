

# 安全联邦学习（secure federated learning）

# 横向联邦学习（horizontal federated learning），
    横向联邦学习(Horizontal Federated Learning，HFL)也称按样本划分的联邦学习，可以应用于联邦学习的各个参与方的数据集有相同的特征空间和不同的样本空间的场景，类似于在表格视图中对数据进行水平划分。
    举例，两个地区的城市商业银行可能在各自的地区拥有非常不同的客户群体，所以他们的客户交集非常小，他们的数据集有不同的样本ID。
    但是他们的业务模型非常相似，因此他们的数据集的特征空间是相同的，这两家银行可以联合起来进行横向联邦学习来构建更好的风控模型。
    横向联邦学习，要求所有的参与方具有相同的特征空间，最后学习的特征是A、B的交集，用户是A、B的并集。
    HFL系统的训练过程：
    1.各参与方在本地计算模型梯度，并使用同态加密、差分隐私或秘密共享等加密技术，对梯度信息进行掩饰，并将掩饰后的结果（简称 加密梯度）发送给聚合服务器；
    2.服务器进行安全聚合(secure aggregation)操作，如使用基于同态加密的加权平均
    3.服务器将聚合后的结果发送给各参与方；
    4.各参与方对收到的梯度进行加密，并使用解密后的梯度结果更新各自的模型参数

# 纵向联邦学习（vertical federated learning）
    纵向联邦学习（Vertical Federated Learning，VFL）也可以理解为 按特征划分的联邦学习，可应用于数据集上具有相同的样本空间、 不同的特征空间的参与方所组成的联邦学习。 
    出于不同的商业目的，不同组织拥有的数据集通常具有不同的特征空间，但这些组织可能共享一个巨大的用户群体。 
    通过使用VFL，我们可以利用分布于这些组织的异构数据，搭建更好的机器学习模型，并且不需要交换和泄露隐私数据。
    纵向联邦学习，要求所有的参与方具有相同的样本空间，最后学习的特征是A、B的并集，用户是A、B的交集。
    VFL系统的一般过程：
    1.加密实体对齐（由于A方和B方公司的用户群体不同，系统使用一种基于加密的用户ID对齐技术）
    样本对齐：首先对齐企业A和企业B中具有相同ID（Identification）的样本数据。在数据对齐阶段，系统会采用加密算法对数据进行保护，确保任何一方的用户数据不会暴露。
    2.加密模型训练（分为4个步骤）：
    2.1.协调者C创建密钥对，并将公共密钥发送给A方和B方
    2.2.A方和B方对中间结果进行加密和交换。中间结果用来帮助计算梯度和损失值
    2.3.A方和B方计算加密梯度并分别加入附加掩码（additional mask）。B方还会计算加密损失。A方和B方将加密的结果发送给C方
    2.4.C方对梯度和损失信息进行加密，并将结果发送会A方和B方。A方和B方解除梯度信息上的掩码，并根据这些梯度信息来更新模型参数
    3.部署应用
    模型联合训练完成后就可以投入生产环境部署应用。
    由于纵向联邦中每个参与方具有部分模型结构，因此推理也需要双方协作完成计算。
    联合推理过程和联合训练类似，首先第三方协作者C将推理数据ID发送给企业A和B，双方在本地完成推理计算后将结果加密后传输到第三方协作者C，由C计算模型最终的联合推理结果。
    VFL算法，其中两种，如：安全联邦线性回归 和 安全联邦提升树(SecureBoost，2019)

# 联邦迁移学习（federated transfer learning）
    HFL和VFL要求所有的参与方具有相同的特征空间或样本空间，从而建立起一个有效的共享机器学习模型。
    但是，在更多的实际情况下，各个参与方拥有的数据集可能存在高度的差异：
    参与方的数据集之间可能只有少量的重叠样本和特征；
    这些数据集的分布情况可能差别很大；
    这些数据集的规模可能差异巨大；
    某些参与方可能只有数据，没有或只有很少的标注数据
    为解决上述问题，联邦学习可以结合迁移学习技术，使其可以应用于更广的业务范围，同时可以帮助只有少量数据（较少重叠的样本和特征）和若监督（较少标记）的应用建立有效且精确的机器学习模型，并且遵守数据隐私和安全条例的规定。 
    将这种组合称为 联邦迁移学习。

# 安全多方计算(Secure Multiparty Computation (SMC)）
    SMC安全模型涉及多方，并在定义明确的仿真框架中提供安全性证明，以确保完全零知识，也就是说，除了输入和输出外，每一方都不知道。零知识是高度期望的，但是这种期望的属性通常需要复杂的计算协议，并且可能无法有效实现。

# 差分攻击(differential attack)
    差分攻击是通过比较分析有特定区别的明文在通过加密后的变化传播情况来攻击密码算法的。
    一个简单的差分攻击例子：假设某医院具备电子化的候诊大屏幕，显示的是当前候诊人数准确的数字，
    在某人进去之前显示当前排队90人，进入之后显示当前排队91人，则现场的人会认为他是来看病的，而不是来看望朋友的，医院就泄露了一部分隐私。

# 差分隐私（Differential Privacy）
    差分隐私（Differential privacy, DP）就是为了解决差分攻击而引入的解决方案，是一种隐私保护模型，可以有效防止研究人员从查询接口中找出自然人的个人隐私数据。
    其原理是在原始的查询结果（数值或离散型数值）中添加干扰数据（即噪声）后，再返回给第三方研究机构；加入干扰后，可以在不影响统计分析的前提下，无法定位到自然人，从而防止个人隐私数据泄露。
    给数据添加噪声，或使用归纳法掩盖某些敏感属性，直到第三方无法区分个人为止，从而使数据无法恢复保护用户隐私。但是，这些方法的根本仍然要求将数据传输到其他地方，这通常需要在准确性和隐私之间进行权衡。
    差分隐私（英语：differential privacy）是密码学中的一种手段，旨在提供一种当从统计数据库查询时，最大化数据查询的准确性，同时最大限度减少识别其记录的机会。

# 同态加密（Homomorphic Encryption）
    同态加密（Homomorphic Encryption）是指将原始数据经过同态加密后，对得到的密文进行特定的运算，然后将计算结果再进行同态解密后得到的明文等价于原始明文数据直接进行相同计算所得到的数据结果。
    目前，全同态加密算法的现有方案均存在计算和存储开销大等问题，距离高效的工程应用还有着不小的差距，同时还面临国际与国内相关标准的缺失，因此在半同态加密算法满足需求的情况下要优先使用半同态加密算法。

# 部分同态加密（partially homomorphic）
    部分同态加密算法允许某一操作被执行无限次。例如，一个特定的算法可能是加法同态的，这意味着将两个密文相加会产生与加密两个明文之和相同的结果。
    加法同态：该加密方案支持的同态函数族为所有可以仅由加法实现的函数。目前使用比较广泛的是paillier加法同态。
    乘法同态：该加密方案支持的同态函数族为所有可以仅由乘法实现的函数。比如经典的RSA加密方案。

# 稍微同态加密（somewhat homomorphic）
    有点同态加密算法可以对密文进行有限次数的任意操作，例如，某种程度的同态加密算法可以支持最多五种加法或乘法的任意组合。但是，任何一种类型的第六次操作都将产生无效的结果。

# 全同态加密（fully homomorphic）
    可以对密文进行无限次数的任意同态操作，也就是说它可以同态计算任意的函数。
    全同态加密(Fully Homomorphic Encryption)，支持对密文进行任意计算的密码系统称为全同态加密 (FHE)。
    这种方案能够为任何所需功能构建程序，这些功能可以在加密输入上运行以产生结果加密。
    由于这样的程序永远不需要解密其输入，因此它可以由不受信任的一方运行，而不会泄露其输入和内部状态。

# 联邦平均算法（Federated Adveraging，FedAvg）
    联邦平均算法：客户端在本地训练完成之后，上传本地模型参数到服务端，服务端再将所有收集的参数值求平均，获得全局模型参数。
    联邦平均算法（Federated Adveraging，FedAvg），分为梯度平均和模型平均。
    两者均为聚合服务器收到参与方的梯度信息或模型参数 进行 计算加权平均时使用的方法。

# 隐私集合求交（Private Set Intersection，PSI）
    隐私集合求交(Private Set Intersection，PSI)是指，参与双方在不泄露任何额外信息的情况下，得到双方持有数据的交集。在这里，额外的信息指的是除了双方的数据交集以外的任何信息。
    隐私集合求交（Private Set Intersection，PSI）技术是纵向联邦学习中数据样本对齐的常用解决方案。
    业界PSI实现方案有多种：基于电路、基于公钥加密、基于不经意传输协议和基于全同态加密等。
    不同PSI方案各有优劣势。例如，基于公钥加密方案不需要辅助服务器运行，但公钥加密的计算开销大；而基于不经意传输方案计算性能高，但通信开销较大。
    因此在具体应用时，要根据实际场景来选择功能、性能和安全之间的最佳平衡方案。

# 盲签名（Blind Signature）
    盲签名实现了签名者对发送者的消息进行签名，却不能知道签名者消息的具体内容。相当于将文件放入信封，签名者在信封上对文件进行签名，而不知道具体的文件内容。
    盲签名的实现方式盲签名的实现方式有很多，比如基于RSA的盲签名，基于BLS的盲签名，基于Schnorr的盲签名，基于MDSA的盲签名，基于NR签名的盲签名，基于身份的盲签名，基于SM9数字签名的盲签名等。

# 对称加密：
    需要对加密和解密使用相同密钥的加密算法。由于其速度快，对称性加密通常在消息发送方需要加密大量数据时使用。对称性加密也称为密钥加密。
    所谓对称，就是采用这种加密方法的双方使用方式用同样的密钥进行加密和解密。密钥是控制加密及解密过程的指令。算法是一组规则，规定如何进行加密和解密。
    因此加密的安全性不仅取决于加密算法本身，密钥管理的安全性更是重要。因为加密和解密都使用同一个密钥，如何把密钥安全地传递到解密者手上就成了必须要解决的问题。

# 非对称加密
    加密和解密秘钥不同，一个是公钥一个是私钥
    优点:加密强度小，加密时间长，常用于数字签名和加密秘钥; 非对称加密算法有两种密钥，其中一个是公开的，所以在密钥传输上不存在安全性问题，使得其在传输加密数据的安全性上又高于对称加密算法。
    缺点:加密解密的速度远远低于对称加密算法，因此不适用于数据量较大的情况

# RSA加密算法
    RSA加密算法是一种非对称加密算法，密钥为一对公钥和私钥组成。通常把公钥发送给使用方，私钥由接收方自己保存
    RSA优点: 解决了对称加密算法如何保存密钥的问题
    RSA缺点: 由于RSA算法的原理都是大数计算，使得RSA最快的情况也比对称加密算法慢上好几倍。速度一直是RSA的缺陷,一般来说RSA只用于小数据的加密.RSA的速度是对应同样安全级别的对称加密算法的1/1000左右。
    RSA的长度: 
    **秘钥长度：**秘钥长度一般是96bits~1024bits
    **明文长度：**明文的长度（bytes） <= 秘钥长度（bytes） - 1（bytes）这样 128字节（1024bits）-减去11字节正好是117字节 。所以明文长度的最大值决定了RSA的最大瓶颈也就是一次加密的数量有限，可以用分片来解决，但分片的方法某些情况下给服务器解密带来一定的问题。
    最佳解决方案： AES+RSA混合加密
    密文长度：不分片：密文长度 = 明文长度；分片： 密文长度 = 秘钥长度 * 片数
    RSA特点: 公钥加密，私钥解密。加密的系统和解密系统分开部署。加密的系统不应该同时具备解密的功能
    注意：RSA加密的明文最大长度117字节，如果超过117字节则程序会报错

