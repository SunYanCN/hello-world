
# 输出查询结果的第三列：
curl 192.168.3.105:9200/_cat/indices/*kg*_alias|awk '{print $3}'

# 1、打印文件的第一列(域)
awk '{print $1}' filename

2、打印文件的前两列(域)
awk '{print $1,$2}' filename

3、打印完第一列，然后打印第二列
awk '{print $1 $2}' filename

4、打印最后一列：
gswyhq@gswyhq-PC:~/yhb$ ls -al|awk '{print $NF}'

# 查找某个程序的进程，再批量kill掉：
gswyhq@gswyhq-PC:~/yhb$ ps -aux|grep draw|awk '{print $2}'|xargs kill

# awk求解字符串的长度：
head train3.txt |awk '{print length($0)}'
11
10

# awk给文本文件每行添加行号， 插入行号, 下面例子是插入行号及tab建
awk '$0=NR"\t"$0' semantic_test.txt > semantic_test2.txt
此处`NR`代表的就是插入的行号
同理，如需要在每行的末尾插入行号，并且用字符‘---’隔开：
awk '$0=$0"---"NR' semantic_test.txt
除了插入行号外，我们也可以在行首或行尾插入其他的固定字符：
awk '$0="句子开头\t"$0"\t句子结尾"' semantic_test.txt

# 取出前三列，并用tab键进行分割：
head test.txt |awk '{print $1"\t"$2"\t"$3}'

awk指定分隔符：
$ head ratings.csv |awk -F "," '{print $3}'
或者：
$ head ratings.csv |awk 'BEGIN{FS=","}''{print $3}'
# 注意，两个单引号之间是没有空格的；或者改成：
$ head ratings.csv |awk 'BEGIN{FS=","}{print $3}'

多分隔符：
head io.log | awk -F "aaa|bbb" '{print $2}'

# awk时间函数：
# systime函数返回当前时间戳
gswyhq@gswyhq-PC:~/data$ awk 'BEGIN{print systime()}'
1576475261
gswyhq@gswyhq-PC:~/data$ awk 'BEGIN{now=systime();print now}'
1576475186
# strftime函数，可以对时间戳进行格式化，格式化形式可以为%Y-%m-%d等（可见下表），如果函数有传参时间戳，则相应进行时间戳的格式转化，如果函数当中没有传参，则默认使用当前时间戳进行格式转化
strftime函数使用格式如下：
strftime([format],[ timestamp])
gswyhq@gswyhq-PC:~/data$ awk 'BEGIN{tmp=strftime("%Y-%m-%d %H:%M:%S",1576474706);print tmp}'
2019-12-16 13:38:26
# mktime函数创建指定时间，转化为时间戳
mktime函数用法如下：
mktime(YYYY" "MM" "DD" "HH" "MM" "SS)
注意必须使用空格分割
其中YYYY为年 MM为月 DD为日 HH为小时 MM是分 SS为秒，如2018" "09" "20" "20" "22" "30
gswyhq@gswyhq-PC:~/data$ awk 'BEGIN{print mktime(2018" "09" "20" "20" "22" "30)}'
1537446150




