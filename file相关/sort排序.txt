# 最近新建的文件在最后：
gswyhq@gswyhq-PC:~/test$ ls -ltr

# 最近新建的文件在最前：
gswyhq@gswyhq-PC:~/test$ ls -lt

gswyhq@gswyhq-PC:~/test$ ls -al |sort +5 # 对第六列进行排序，增序排序
gswyhq@gswyhq-PC:~/test$ ls -al |sort +5 +6 +7
gswyhq@gswyhq-PC:~/test$ ls -al |sort -r +5 +6 +7  # 逆序排列

按字符串长度升序排序：
less abc.txt|sort -n

# 若需要按数字排序，则需要使用-n:
若遇到过10比2小的情况。出现这种情况是由于排序程序将这些数字按字符来排序了，排序程序会先比较1和2，显然1小，所以就将10放在2前面。
如果想改变这种现状，就要使用-n选项，来告诉sort，“要以数值来排序”
sort -n number.txt

# 按字符串长度降序排序：
less abc.txt|sort -nr

# 指定分隔符分割，按指定列排序：
$ sort -n -k 2 -t : facebook.txt
apple:10:2.5
orange:20:3.4
banana:30:5.5
pear:90:2.3

这里使用冒号作为间隔符(-t选项)，并针对第二列(-k选项)来进行数值(-n选项)升序(无-r时默认是升序)排序

# 优先按第3列降序排列，在第三列相同时，按第2列升序排序：
$ sort -n -t ' ' -k 3r -k 2 facebook.txt
baidu 100 5000
google 110 5000
sohu 100 4500
guge 50 3000

# 对第一列的第二个字母进行排序：
$ sort -t ' ' -k 1.2 facebook.txt
baidu 100 5000
sohu 100 4500
google 110 5000
guge 50 3000

使用了-k 1.2，这就表示对第一个域的第二个字符开始到本域的最后一个字符为止的字符串进行排序。

# 只针对公司英文名称的第二个字母进行排序，如果相同的按照员工工资（第三列）进行降序排序：
$ sort -t ' ' -k 1.2,1.2 -k 3,3nr facebook.txt
baidu 100 5000
google 110 5000
sohu 100 4500
guge 50 3000

由于只对第二个字母进行排序，所以我们使用了-k 1.2,1.2的表示方式，表示我们“只”对第二个字母进行排序。（“使用-k 1.2怎么不行？”，是因为省略了End部分，这就意味着将对从第二个字母起到本域最后一个字符为止的字符串进行排序）。对于员工工资进行排序，我们也使用了-k 3,3，这是最准确的表述，表示我们“只”对本域进行排序，因为如果你省略了后面的3，就变成了我们“对第3个域开始到最后一个域位置的内容进行排序” 了。

# sort的-u选项
它的作用很简单，就是在输出行中去除重复行。
$ sort -u seq.txt
$ cat facebook.txt
google 110 5000
baidu 100 5000
guge 50 3000
sohu 100 4500
$ sort -n -k 2 -u facebook.txt
guge 50 3000
baidu 100 5000
google 110 5000

当设定以公司员工域进行数值排序，然后加-u后，sohu一行就被删除了！原来-u只识别用-k设定的域，发现相同，就将后续相同的行都删除。

$ sort -n -k 2 -k 3 -u facebook.txt
guge 50 3000
sohu 100 4500
baidu 100 5000
google 110 5000

这里设置了两层排序优先级的情况下，使用-u就没有删除任何行。原来-u是会权衡所有-k选项，将都相同的才会删除，只要其中有一级不同都不会轻易删除

$ sort -n -k 2.2,3.1 facebook.txt
guge 50 3000
baidu 100 5000
sohu 100 4500
google 110 5000

以第二个域的第二个字符开始到第三个域的第一个字符结束的部分进行排序。
第一行，会提取0 3，第二行提取00 5，第三行提取00 4，第四行提取10 5。
又因为sort认为0小于00小于000小于0000….
因此0 3肯定是在第一个。10 5肯定是在最后一个。但为什么00 5却在00 4前面呢?
答案揭晓：原来“跨域的设定是个假象”，sort只会比较第二个域的第二个字符到第二个域的最后一个字符的部分，而不会把第三个域的开头字符纳入比较范围。当发现00和00相同时，sort就会自动比较第一个域去了。当然baidu在sohu前面了.

# 但是对于tab分隔符，还是得稍微注意一下。比如下面的命令：
$sort -t '\t' -k3,3n a.txt >a.sort
sort: multi-character tab `\t'  (出错）
或者：sort -t \t -k3,3n a.txt 
虽说没有报错，但实际上结果不对，并没有安装 tab键进行分割；
这个不能按照tab分隔符进行字段排序，换成如下两种方式就可以了
方式1,
$ sort  -t $'\t' -k3,3n a.txt>a.sort

方式2,
$ sort -t'<ctrl>v<tab>' -k3,3n a.txt>a.sort
<ctrl>v<tab>代表先同时按下Ctrl和v键，然后松开，按下tab键。

# 根据指定列进行去除重复行：
sort md5_20230606.log -k1| awk -F " " '!i[$1]++' > md5_20230606_2.log 
-k1: 是指根据第1列进行排序；
用awk对相邻两行数据进行比较如果第一列的数据相同则去除重复行(保留第一个相同的行)

# 对单行字符串进行分割并进行排序：
 echo "10|11|12|1|23|2|13|3|15|16|7|40|20" | tr '|' '\n' | sort -n|tr '\n' '|'
1|2|3|7|10|11|12|13|15|16|20|23|40|
或者：
echo -n $(echo "10|11|12|1|23|2|13|3|15|16|7|40|20" | tr '|' '\n' | sort -n)|tr ' ' '|'

